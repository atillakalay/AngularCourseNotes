# Angular

# *Angular Nedir?*

Angular, Google tarafından geliştirilen açık kaynaklı bir JavaScript framework'üdür. Web uygulamaları oluşturmak için kullanılan bir araçtır ve Model-View-Controller (MVC) tasarım desenini kullanır.

Angular, uygulamaların modüler ve ölçeklenebilir olmasını sağlar. Özellikle tek sayfa uygulamaları (Single Page Application) geliştirme konusunda güçlü bir araçtır ve birçok büyük şirket tarafından kullanılmaktadır.

Angular, HTML, CSS ve JavaScript kullanarak uygulama geliştirmeyi kolaylaştırmak için bir dizi özellik ve bileşenler sağlar. Bu özellikler arasında veri bağlama (data binding), dependency injection, routing, form kontrolü ve animasyonlar gibi özellikler bulunur.

Angular, büyük ve karmaşık uygulamaların geliştirilmesi için uygun bir araçtır ve geliştiricilerin üretkenliğini artırmak için birçok araç sağlar.

# *Angular’ ın Avantajları ve Dezavantajları Nelerdir?*

***Avantajları:***

1. ***Modüler ve Ölçeklenebilir:** Angular, uygulamanızı modüler hale getirerek ölçeklenebilir hale getirmenizi sağlar. Angular, büyük ve karmaşık uygulamaların geliştirilmesini kolaylaştırır.*
2. ***Veri Bağlama (Data Binding):** Angular, veri bağlama özelliği sayesinde uygulamanızdaki verilerin otomatik olarak güncellenmesini sağlar. Bu, uygulamanızdaki kodun daha temiz ve okunaklı olmasını sağlar.*
3. ***Dependency Injection:** Angular, dependency injection özelliği sayesinde bileşenler arasındaki bağımlılıkları yönetmenizi sağlar. Bu özellik, kodunuzu daha az karmaşık ve daha kolay anlaşılır hale getirir.*
4. *T**ypeScript:** Angular, TypeScript kullanarak geliştirme yapmanıza olanak tanır. TypeScript, JavaScript'e güçlü bir tip kontrolü ekler ve kodunuzu daha güvenli hale getirir.*
5. ***Büyük Bir Topluluk:** Angular, büyük bir geliştirici topluluğuna sahiptir. Bu topluluk, Angular hakkında birçok kaynak ve yardım sunar.*

***Dezavantajları:***

1. ***Öğrenme Eğrisi:** Angular, öğrenmesi zor bir framework'tür. Angular kullanmaya başlamak için, geliştiricilerin daha önce JavaScript, HTML ve CSS hakkında bilgi sahibi olmaları gerekmektedir.*
2. ***Performans:** Angular, diğer JavaScript framework'leri ile karşılaştırıldığında biraz daha yavaş performans gösterebilir. Bu, büyük uygulamalarda özellikle fark edilebilir olabilir.*
3. ***Kod Miktarı:** Angular, diğer JavaScript framework'lerine göre daha fazla kod yazmanızı gerektirir. Bu, geliştirme süresini biraz daha uzatabilir.*
4. ***Güncelleme Sorunları:** Angular, yeni bir sürüm çıkardığında, eski sürümlerle uyumlu olmayabilir. Bu da güncelleme yaparken sorunlar yaşanmasına neden olabilir.*
5. ***Boyut:** Angular, diğer JavaScript framework'leri ile karşılaştırıldığında daha büyük boyutta olabilir. Bu, uygulamanın yükleme süresini uzatabilir.*

# *Single Page Application Nedir?*

Single Page Application (SPA), bir web uygulaması tipidir. Kullanıcıların sayfalar arasında gezinmesine gerek kalmadan, tek bir sayfa içerisinde uygulamanın tüm fonksiyonlarına erişmesini sağlar.

SPA, geleneksel çok sayfalı web uygulamalarına göre daha hızlı ve kullanımı daha kolaydır. SPA'lar, kullanıcı tarafından yapılan etkileşimler sonucunda sadece gerekli olan verileri veya bileşenleri yükleyerek sayfa yenilemesine gerek kalmadan içeriklerin güncellenmesini sağlar.

SPA'lar genellikle JavaScript framework'leri ile geliştirilir ve bu framework'lerin sağladığı veri bağlama (data binding) ve yönlendirme (routing) özellikleri ile uygulamaların geliştirilmesi kolaylaştırılır.

*SPA'ların avantajları şunlardır:*

- ***Kullanıcı deneyimi:** SPA'lar, kullanıcıların sayfalar arasında geçiş yapmak yerine uygulamanın tüm fonksiyonlarına tek bir sayfa içinde erişebilmelerini sağlar. Bu da kullanıcı deneyimini artırır.*
- ***Hız:** SPA'lar, sadece gerekli olan verileri veya bileşenleri yükleyerek sayfa yenilemesine gerek kalmadan içeriklerin güncellenmesini sağlar. Bu da uygulamanın hızını artırır.*
- ***Kolay bakım:** SPA'lar, geleneksel çok sayfalı web uygulamalarına göre daha az sayfa içerir. Bu da uygulamanın bakımını daha kolay hale getirir.*
- ***Veri bağlama ve yönlendirme:** SPA'lar, JavaScript framework'leri ile geliştirildiği için veri bağlama ve yönlendirme gibi özellikleri kolayca kullanabilirler.*

*Ancak, SPA'ların dezavantajları da vardır. SPA'ların dezavantajları şunlardır:*

- ***SEO sorunları:** SPA'lar, arama motorları tarafından doğru şekilde indekslenemediğinde SEO sorunlarına neden olabilir.*
- ***Başlangıç yükü:** SPA'lar, ilk yükleme sırasında tüm kaynak dosyalarını indirmek zorunda olduğundan başlangıç yükü geleneksel çok sayfalı web uygulamalarına göre daha yüksek olabilir.*
- ***Browser uyumluluğu:** SPA'lar, tüm modern tarayıcılar tarafından desteklenmektedir ancak bazı eski tarayıcılarla uyumlu olmayabilir.*

# *Node.js Nedir?*

Node.js, Chrome V8 JavaScript motoru üzerine kurulmuş bir JavaScript runtime ortamıdır. Node.js, server-side (sunucu tarafı) JavaScript çalıştırabilen açık kaynaklı bir platformdur.

Node.js, JavaScript dilini kullanarak hızlı ve ölçeklenebilir web uygulamaları geliştirilmesine olanak sağlar. Node.js, JavaScript'in yaygın kullanımına olanak sağladığı için, web tarayıcılarındaki JavaScript koduyla benzer bir şekilde çalıştırılabildiği için, sunucu tarafındaki uygulamaları da JavaScript kullanarak geliştirme fırsatı sunar.

Node.js, asenkron (non-blocking) I/O işlemleri ile çalıştığından, web uygulamalarının hızını arttırır. Ayrıca, Node.js, modüler bir yapıya sahiptir ve özellikle hızlı ve ölçeklenebilir web uygulamaları için tasarlanmıştır.

Node.js, birçok farklı alanda kullanılmaktadır. Örneğin, web uygulamaları, arka uç uygulamaları, oyun sunucuları, akışlı uygulamalar, API'ler ve IoT (Nesnelerin İnterneti) cihazları için kullanılabilir.

*Node.js'in avantajları şunlardır:*

- ***Hız:** Node.js, asenkron I/O işlemleri ile çalıştığından web uygulamalarının hızını arttırır.*
- ***Ölçeklenebilirlik:** Node.js, ölçeklenebilir web uygulamaları geliştirmek için tasarlanmıştır.*
- ***Modüler yapı:** Node.js, modüler bir yapıya sahiptir ve kullanıcılar tarafından geliştirilen modüllerin kullanılmasına olanak sağlar.*
- ***Çoklu platform desteği:** Node.js, Windows, Linux ve Mac OS X gibi farklı işletim sistemlerinde çalışabilir.*
- ***Geniş topluluk desteği:** Node.js, açık kaynaklı bir platform olduğundan geniş bir topluluk tarafından desteklenmektedir.*

*Ancak, Node.js'in dezavantajları da vardır:*

- ***CPU yoğun işlemler için uygun değildir:** Node.js, CPU yoğun işlemler için uygun değildir çünkü JavaScript'in tek bir iş parçacığında çalışması gerekmektedir.*
- ***Bellek yönetimi:** Node.js, bellek yönetimi için özel teknikler kullanır ve bu tekniklerin kullanımı zor olabilir.*
- ***Güvenlik:** Node.js, diğer sunucu taraflı programlama dillerine göre daha az güvenli kabul edilir.*

# *Angular CLI Nedir?*

Angular CLI (Command Line Interface), Angular uygulamaları için bir komut satırı arayüzüdür. Angular CLI, Angular uygulamalarının hızlı bir şekilde oluşturulmasını, yapılandırılmasını ve dağıtılmasını kolaylaştırır. Bu araç, kullanıcıların Angular uygulamalarını sıfırdan başlatmak yerine hazır bir şablon kullanarak hızlı bir şekilde oluşturmasına olanak sağlar.

Angular CLI, kullanıcıların Angular projesi için birçok işlemi otomatikleştirmesine olanak sağlar. Bu işlemler arasında, proje yapısının oluşturulması, dosya oluşturulması, paketlerin yüklenmesi, testlerin çalıştırılması, uygulamanın derlenmesi ve uygulamanın sunucuya yüklenmesi gibi işlemler bulunur.

Angular CLI ayrıca, Angular uygulamalarını oluşturmak ve yönetmek için kullanılan birçok komut sunar. Örneğin, "ng new" komutu yeni bir Angular projesi oluştururken, "ng serve" komutu geliştirme sunucusunu başlatır. "ng test" komutu, Angular uygulaması için testleri çalıştırmak için kullanılır.

Angular CLI, Angular uygulamalarının geliştirilmesi ve yönetilmesinde büyük bir kolaylık sağlar. Bu araç, geliştirme sürecinde zaman kazandırır ve uygulamanın yapılandırılması ve dağıtılması işlemlerini daha hızlı ve kolay hale getirir.

# *TypeScript Nedir?*

TypeScript, Microsoft tarafından geliştirilmiş, açık kaynak kodlu bir programlama dilidir. TypeScript, JavaScript dilinin bir üst kümesidir ve JavaScript ile aynı söz dizimi ve yapısına sahiptir. Ancak, TypeScript, JavaScript'in özelliklerine ek olarak, statik tür atamaları, sınıflar, arayüzler ve nesne yönelimli programlama özellikleri gibi bir dizi ek özellik sunar.

TypeScript, JavaScript kodunun okunabilirliğini artırır ve daha büyük ölçekli projelerde daha güvenli ve daha kolay bir kod yazımı sağlar. Bu özellikleri sayesinde, özellikle büyük ekipler tarafından geliştirilen ve ölçeklenebilir projelerde kullanılan web uygulamalarının geliştirilmesinde popüler bir dil haline gelmiştir.

*TypeScript'in avantajları şunlardır:*

- ***Statik tür atama:** TypeScript, statik tür atamaları kullanarak hataların erken tespit edilmesine ve kod kalitesinin artırılmasına olanak sağlar.*
- ***Nesne yönelimli programlama:** TypeScript, nesne yönelimli programlama özelliklerini destekler ve kodun yeniden kullanımını kolaylaştırır.*
- ***Geliştirme sürecinde hızlı geri bildirim:** TypeScript, geliştirme sürecinde hızlı geri bildirim sağlayarak, hataların hızlı bir şekilde tespit edilmesini sağlar.*
- ***JavaScript uyumluluğu:** TypeScript, JavaScript kodunun aynen kullanılmasına olanak sağlar ve mevcut JavaScript kodlarının TypeScript'e dönüştürülmesini kolaylaştırır.*
- ***Daha büyük projeler için ölçeklenebilirlik:** TypeScript, büyük projeler için ölçeklenebilir bir yapı sunar ve kodun daha iyi organize edilmesini sağlar.*

*Ancak, TypeScript'in dezavantajları da vardır:*

- ***Ekstra öğrenme eşiği:** TypeScript, ek özellikleri nedeniyle JavaScript'ten daha karmaşık bir dil olarak algılanabilir ve ek öğrenme eşiği gerektirir.*
- ***Yazılım boyutu:** TypeScript, statik tür atamaları nedeniyle JavaScript koduna göre daha büyük bir boyuta sahip olabilir.*
- ***Başlangıç zorluğu:** TypeScript, yüklemesi ve yapılandırması JavaScript'e göre daha karmaşık olabilir.*

# *Angular da Interface Kullanımı*

Angular, TypeScript dili üzerine inşa edilmiş bir web framework'üdür. TypeScript, nesne yönelimli programlama (OOP) özelliklerine sahip bir dildir ve bunun bir parçası olarak, arayüzler (interfaces) kullanımı önemli bir yer tutar. Angular, bu arayüzlerin kullanımını teşvik eder ve uygulamanın yapılandırılmasına yardımcı olur.

Angular uygulamaları genellikle bileşenlere (component) ve hizmetlere (service) ayrılmıştır. Bu bileşenler ve hizmetler, arayüzlerle belirlenmiş bir dizi özelliği (property) ve işlevi (method) içerir. Arayüzler, bu özellikleri ve işlevleri tanımlamak için kullanılır ve kodun okunabilirliğini ve yeniden kullanılabilirliğini artırır.

*Örneğin, aşağıdaki örnek bir arayüz tanımıdır:*

```jsx
interface User {
  id: number;
  name: string;
  email: string;
  age?: number;
}
```

Bu arayüz, "User" adlı bir nesne türünü tanımlar. Bu nesne, "id", "name" ve "email" adlı zorunlu özelliklere sahiptir ve "age" adlı isteğe bağlı bir özellik içerebilir.

Bu arayüz, bir bileşen veya hizmet tarafından kullanılabilir. Örneğin, aşağıdaki örnek bileşen, "User" arayüzünü kullanarak bir kullanıcı listesini görüntüler:

```jsx
import { Component } from '@angular/core';
interface User {
  id: number;
  name: string;
  email: string;
  age?: number;
}
@Component({
  selector: 'app-user-list',
  templateUrl: './user-list.component.html',
  styleUrls: ['./user-list.component.css']
})
export class UserListComponent {
  users: User[] = [
    { id: 1, name: 'John Doe', email: 'john@example.com' },
    { id: 2, name: 'Jane Doe', email: 'jane@example.com', age: 28 },
    { id: 3, name: 'Bob Smith', email: 'bob@example.com', age: 35 }
  ];
}
```

Bu bileşen, "User" arayüzü ile tanımlanmış bir "users" özelliğine sahiptir. Bu özellik, "User" türünde bir dizi nesne içerir ve bileşen tarafından kullanılabilir.

Arayüzlerin kullanımı, Angular uygulamalarının yapılandırılmasına yardımcı olur ve özellikle büyük ölçekli projelerde kodun okunabilirliğini ve yeniden kullanılabilirliğini artırır.

# *Component Nedir?*

Component, Angular framework'ünde bir web bileşenidir. Bir bileşen, bir web sayfasındaki belirli bir parçayı temsil eder ve HTML şablonu, CSS stilleri ve TypeScript kodu içerir.

Angular uygulamaları, birçok bileşenin bir araya gelmesiyle oluşturulur. Bu bileşenler, uygulamanın farklı bölümlerini temsil eder ve birbirleriyle etkileşimde bulunabilirler.

Bir bileşenin temel öğeleri şunlardır:

- **Component Decorator**: Bileşenin özelliklerini ve davranışlarını tanımlayan bir TypeScript sınıfıdır. Bu sınıf, @Component dekoratörü ile işaretlenir ve bileşenin adını, seçicisini, şablonunu ve stil dosyalarını belirler.
- **HTML Template**: Bileşenin görsel tasarımını tanımlar. HTML şablonu, bileşenin verilerini ve özelliklerini gösteren etiketler ve diğer görsel öğeler içerir.
- **Component Class**: Bileşenin işlevselliğini tanımlayan TypeScript sınıfıdır. Bu sınıf, bileşenin veri özelliklerini ve işlevlerini tanımlar ve bileşenin davranışını kontrol eder.
- **Metadata**: Bileşenin özelliklerini tanımlayan bir JavaScript nesnesidir. Bu nesne, @Component dekoratörü tarafından tanımlanır ve bileşenin adını, seçicisini, şablonunu, stil dosyalarını ve diğer özelliklerini belirler.

        Bir bileşen, bir web sayfasında birden fazla kez kullanılabilir ve yeniden kullanılabilirliği artırır. Bileşenler, Angular uygulamalarının modüler yapısını oluşturur ve farklı bileşenlerin bir araya gelmesiyle uygulamanın bütününü oluşturur.

# *Module ve Component İlişkisi*

Module ve Component arasında sıkı bir ilişki vardır. Angular uygulamaları, bir veya daha fazla modül ve bu modüllerdeki birçok bileşenin bir araya gelmesiyle oluşturulur.

Modüller, Angular uygulamalarında bir işlevselliği paketlemek için kullanılır. Bir modül, işlevsel birimlerin bir araya getirilmesiyle oluşur ve uygulamanın farklı bölümlerini temsil edebilir. Modüller, bir uygulamanın parçalarını mantıksal gruplar halinde düzenler ve uygulamanın genel yapısını sağlar.

Bir modülün içinde, bileşenler ve diğer servisler gibi farklı türlerdeki öğeler yer alabilir. Bu bileşenler, modüle özgüdür ve modülün dışındaki bileşenlerden farklı olarak, sadece modül içinde kullanılabilirler.

Bir bileşen ise, bir web sayfasındaki belirli bir parçayı temsil eder ve bir modülün içinde yer alabilir. Bir bileşenin özellikleri, modülün özelliklerini kullanabilir ve modül içindeki diğer bileşenlerle etkileşimde bulunabilir.

Bir modül, bileşenlerin gruplandırılmasına ve uygulamanın yönetimine yardımcı olurken, bileşenler, uygulamanın temel yapı taşlarıdır ve uygulamanın görsel tasarımını ve işlevselliğini belirler. Bileşenler, bir web sayfasındaki belirli bir parçayı temsil ederken, modüller uygulamanın farklı bölümlerini temsil eder ve uygulamanın yapısını oluşturur.

# *Component LifeCycle Hooks Nedir?*

Angular'da Component LifeCycle Hooks, bir bileşenin hayat döngüsünü kontrol etmek ve bileşenin farklı aşamalarında işlem yapmak için kullanılan yöntemlerdir. Bileşenin oluşturulması, güncellenmesi veya yok edilmesi gibi durumlarda, Angular, belirli bir sırayla, bileşenin hayat döngüsü kancalarını çalıştırır.

*Angular'da bir bileşenin hayat döngüsü şu adımlardan oluşur:*

1. ***ngOnChanges()**: Bileşenin bağımlılıkları değiştiğinde çağrılır. Bu yöntem, bileşenin özelliklerinde değişiklik olduğunda çalışır.*
2. ***ngOnInit()**: Bileşenin oluşturulduğu ilk kez çağrılır. Bu yöntem, bileşenin tüm özellikleri ve verileri yüklendikten sonra çalışır.*
3. ***ngDoCheck()**: Bileşenin değiştirildiği her zaman çağrılır. Bu yöntem, bileşenin verileri her değiştiğinde çalışır.*
4. ***ngAfterContentInit()**: Bileşenin görüntüleme özellikleri, dış kaynaklardan getirildiğinde çağrılır. Bu yöntem, bileşenin HTML şablonu yüklendikten sonra çalışır.*
5. ***ngAfterContentChecked()**: Bileşenin içeriği veya görüntüleme özellikleri değiştirildiğinde çağrılır. Bu yöntem, bileşenin HTML şablonu yüklendikten sonra her değişiklikte çalışır.*
6. ***ngAfterViewInit()**: Bileşenin görüntüleme özellikleri, bileşenin HTML şablonuna bağlandığında çağrılır. Bu yöntem, bileşenin görüntüleme özellikleri hazır olduğunda çalışır.*
7. ***ngAfterViewChecked()**: Bileşenin görüntüleme özellikleri değiştirildiğinde veya güncellendiğinde çağrılır. Bu yöntem, bileşenin görüntüleme özellikleri hazır olduğunda her değişiklikte çalışır.*
8. ***ngOnDestroy()**: Bileşen yok edildiğinde çağrılır. Bu yöntem, bileşenin hafızadan silinmeden önce temizlenmesi için kullanılır.*

Bu LifeCycle Hooks yöntemleri, bir bileşenin hayat döngüsünü kontrol etmek ve bileşenin farklı aşamalarında işlem yapmak için kullanılır. Bu yöntemler, bileşenlerin verilerini dinamik olarak değiştirmek, bileşenin görüntüsünü güncellemek ve hafızayı temizlemek için kullanılabilir.

# *Component’ e Dışarıdan Nasıl Veri Taşınır?*

*Angular'da bir bileşene veri taşımak için iki yöntem vardır: @Input ve Service.*

***@Input Decorator Kullanımı**
Bir bileşene veri taşımak için, öncelikle taşınacak verileri sağlayan bir bileşenin oluşturulması gerekir. Bu bileşen, taşınacak veriyi @Input dekoratörü ile birlikte bileşen özelliğine bağlar.*

*Örneğin, bir parent bileşeninde şu şekilde bir bileşen kullanılarak veri taşınabilir:*

```jsx
<app-child-component [veri]="parentVeri"></app-child-component>
```

*`**[veri]**` özelliği, child bileşeninde **`@Input()`** dekoratörü kullanılarak belirtilen bir **`veri`** özelliği ile bağlantılıdır.*

```jsx
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-child-component',
  template: '{{veri}}',
})
export class ChildComponent {
  @Input() veri: string;
}
```

***Service Kullanımı**
Bir diğer yöntem ise, bir Service kullanarak verileri taşımaktır. Service, birden fazla bileşen arasında veri paylaşımı yapmak için kullanılabilir. Veriler, bir bileşen tarafından servise eklenir ve diğer bileşenler tarafından servisten alınır.*

*Örneğin, bir Service ve iki bileşen kullanılarak veri taşınabilir:*

```jsx
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  public veri: string;
}
```

```jsx
import { Component } from '@angular/core';
import { DataService } from './data.service';

@Component({
  selector: 'app-parent-component',
  template: '<button (click)="addData()">Veri Ekle</button>'
})
export class ParentComponent {
  constructor(private dataService: DataService) {}

  addData() {
    this.dataService.veri = 'Merhaba Dünya!';
  }
}
```

```jsx
import { Component } from '@angular/core';
import { DataService } from './data.service';

@Component({
  selector: 'app-child-component',
  template: '{{veri}}'
})
export class ChildComponent {
  constructor(private dataService: DataService) {}

  get veri() {
    return this.dataService.veri;
  }
}
```

*Burada, DataService adlı bir servis oluşturuldu ve ParentComponent, DataService'e bir veri ekledi. ChildComponent, aynı DataService'ye erişerek veriyi alır ve ekrana yazdırır. Bu yöntem, verilerin birden fazla bileşen arasında taşınması gerektiğinde kullanılabilir.*

# *Two-way Binding Nedir?*

*Two-way binding, Angular'da verilerin hem bileşen sınıfı hem de bileşen görünümü arasında çift yönlü olarak senkronize edilmesini sağlayan bir özelliktir. Yani, veri değiştiğinde hem bileşen sınıfında hem de bileşen görünümünde değişiklik yapılır.*

*Bu özellik, [(ngModel)] sözdizimi ile kullanılabilir. [(ngModel)] sözdizimi, veri bağlantısının iki yönlü olmasını sağlayan bir şablon yönergesidir. Bu yönerge, bir input alanındaki veriyi bileşen sınıfındaki bir değişkene bağlayabilir ve aynı zamanda bileşen sınıfındaki bir değişkeni bir input alanına bağlayabilir.*

*Örneğin, bir input alanında girilen metnin hem bileşen sınıfında hem de bileşen görünümünde güncellenmesi için aşağıdaki kod kullanılabilir:*

```jsx
<input [(ngModel)]="username" />
<p>Hoşgeldin, {{username}}!</p>
```

*Burada, [(ngModel)] yönergesi, **`username`** adlı bir değişkene veri bağlantısı yapar. Bu veri bağlantısı, input alanındaki değer değiştiğinde bileşen sınıfındaki **`username`** değişkeninin güncellenmesini sağlar ve aynı zamanda bileşen görünümündeki **`{{username}}`** ifadesinin de güncellenmesini sağlar.*

*Two-way binding, kullanıcının girdiği veriyi bileşen sınıfında işlemek ve aynı zamanda bu veriyi bileşen görünümünde göstermek için kullanışlı bir özelliktir. Ancak, performans nedenleriyle bazı durumlarda tek yönlü veri bağlantısı tercih edilebilir.*

# *NgOnChanges Hook Nedir?*

`**ngOnChanges**`, Angular'daki bir bileşen ömrü döngüsü kancasıdır (lifecycle hook) ve bir bileşenin girdi özelliklerinde değişiklik olduğunda çağrılır.

Bir bileşenin girdi özellikleri, diğer bileşenler veya bileşenin dışındaki kaynaklar tarafından sağlanabilen verilerdir. Girdi özellikleri, bileşenin dış dünyayla etkileşim kurmasına ve veri alışverişinde bulunmasına olanak tanır.

**`ngOnChanges`**, girdi özelliklerinde değişiklik olduğunda bileşenin verilerinin nasıl güncelleneceğini yönetmek için kullanılır. Bu kancanın kullanımı, bileşenin girdi özelliklerindeki değişikliklerin bileşen içindeki değişkenlere nasıl yansıtılacağını kontrol etmek için kullanılabilir.

Bu kancanın kullanımı aşağıdaki gibi olabilir:

```jsx
import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';

@Component({
  selector: 'app-my-component',
  template: `
    <p>My name is {{name}}.</p>
  `
})
export class MyComponent implements OnChanges {
  @Input() name: string;

  ngOnChanges(changes: SimpleChanges) {
    console.log(changes); // Girdi değişikliklerini konsola yazdırır
  }
}
```

Burada, **`@Input()`** dekoratörü ile **`name`** adlı bir girdi özelliği tanımlanmıştır. **`ngOnChanges`** yöntemi, **`SimpleChanges`** tipindeki bir nesne alır ve değişikliklerin özellik adlarını ve önceki/değiştirilen değerleri içerir. Bu kancayı kullanarak, girdi özelliklerindeki değişiklikleri izleyebilir ve bileşen içindeki diğer değişkenlerin güncellenmesini yönetebilirsiniz.

# *Directives Nedir?*

*Angular'da Directives, DOM manipülasyonları, etkileşimli özellikler ve görünüm yönetimi gibi işlevleri uygulamak için kullanılan özelliklerdir. Directive (Yönerge) bir Component'in yaptığı her şeyi yapabilir. Ancak, farklı olarak Component'ten farklı olarak Directive'in kendisi DOM'a yerleşmez. Directive'ler bir HTML öğesi içinde veya bir bileşen üzerinde kullanılabilir.*

*Angular'da Directives, üç farklı türde olabilir:*

1. ***Component Directives:** Örneğin bir form veya menü öğesi gibi tam bir bileşen.*
2. ***Attribute Directives:** Tek bir HTML öğesi veya bileşenin özelliklerini değiştirmek veya güncellemek için kullanılır. Örneğin, bir HTML elementinin gösterilip gösterilmeyeceğini kontrol etmek için ngIf Directive kullanılabilir.*
3. ***Structural Directives:** DOM'un yapısını değiştirmek için kullanılır. Örneğin ngFor, DOM içinde bir liste öğesi oluşturmak için kullanılabilir.*

*Directive'ler, kod tekrarını önler ve uygulamanın düzenini basitleştirir. Ayrıca, kodda daha az değişiklik yaparak HTML ve CSS'i yeniden kullanmanıza olanak tanır. Directive'ler ayrıca, uygulama performansını artırmak için kullanılan lazy loading gibi ileri seviye Angular tekniklerinde de kullanılabilir.*

# *NgFor Nedir?*

*NgFor, Angular'da Structural Directive olarak kullanılan ve bir dizi veya bir nesne koleksiyonu üzerinde tekrarlayan bir Directive'dir. Bu Directive, liste, tablo veya kart gibi yapıları oluşturmak için sıklıkla kullanılır. NgFor, bir ng-template içinde kullanılır ve genellikle *ngFor olarak yazılır.*

*NgFor Directive, bir veri kaynağından gelen öğeleri HTML şablonuna yerleştirir. Bu, kullanıcıların veri kaynağından dinamik olarak oluşturulmuş bir liste veya tablo gibi bir şey görüntülemesine olanak tanır. NgFor, dizeler, nesne dizileri ve nesneler gibi farklı veri tiplerindeki koleksiyonlar için kullanılabilir.*

*NgFor, bir dizi veya nesne koleksiyonu üzerinde tekrarlanırken, her öğe için geçerli bir öğeyi temsil eden bir referans değişkeni tanımlar. Bu referans değişkeni, şablon içinde veriye erişmek için kullanılabilir. Örneğin, şablon içindeki bir input öğesine bağlanabilir veya bir şablon değişkeninde saklanabilir.*

*NgFor ayrıca bir dizin numarası veya benzersiz bir kimlik değeri gibi diğer öğe özellikleri de sağlar. Bu özellikler, HTML öğelerine benzersiz bir kimlik vermek veya öğeler arasında geçiş yapmak için kullanılabilir.*

*NgFor, Angular'da sıkça kullanılan bir Directive'dir ve dinamik verileri göstermek için oldukça yararlıdır.*

# *NgIf Nedir?*

*NgIf, Angular'da Structural Directive olarak kullanılan ve bir koşula göre bir öğenin görünürlüğünü belirleyen bir Directive'dir. Bu Directive, kullanıcıların belirli bir koşul doğruysa bir öğeyi görüntülemesine olanak tanır.*

*NgIf, bir ng-template içinde kullanılır ve genellikle *ngIf olarak yazılır. Bu Directive, şablon içinde bir öğenin görünürlüğünü kontrol etmek için kullanılır. NgIf, bir koşul doğru olduğunda öğeyi görüntüler ve koşul yanlış olduğunda öğeyi gizler.*

*NgIf, bir boole değeri döndüren bir ifadeyi kabul eder. Bu ifade, true veya false döndürebilir ve genellikle bir bileşen sınıfındaki bir değişkene veya bir işlevin sonucuna dayanır. NgIf ayrıca bir else bloğu ile birlikte kullanılabilir, böylece koşul yanlış olduğunda görüntülenecek alternatif bir öğe sağlar.*

*NgIf, Angular'da sıkça kullanılan bir Directive'dir ve dinamik olarak öğelerin görünürlüğünü değiştirmek için oldukça yararlıdır. Örneğin, bir kullanıcının oturum açıp açmadığını kontrol etmek ve bir sayfada gösterilecek öğeleri belirlemek için kullanılabilir.*

# *NgSwitch Nedir?*

*NgSwitch, Angular'da Structural Directive olarak kullanılan ve bir değişkene göre farklı öğeleri gösteren bir Directive'dir. Bu Directive, bir değişkenin farklı değerlerine göre farklı HTML öğelerini görüntülemek için kullanılır.*

*NgSwitch, bir ng-template içinde kullanılır ve genellikle *ngSwitch olarak yazılır. Bu Directive, bir değişkenin farklı değerlerine göre farklı HTML öğelerini görüntüler. Değişkenin değeri değiştikçe, NgSwitch farklı HTML öğelerini gösterir veya gizler.*

*NgSwitch, bir ngSwitchCase ve bir ngSwitchDefault Directive'ı ile birlikte kullanılır. ngSwitchCase Directive'ı, NgSwitch'in izlediği değişkenin belirli bir değeri ile eşleşen HTML öğelerini tanımlar. ngSwitchDefault Directive'ı, herhangi bir ngSwitchCase değeri ile eşleşmeyen bir HTML öğesi tanımlar.*

*NgSwitch, bir değişkenin farklı değerlerine göre farklı HTML öğelerini görüntülemek için oldukça yararlıdır. Örneğin, bir sayfada farklı içeriklerin görüntülenmesini sağlamak için kullanılabilir, örneğin bir sayfa dil seçeneğine göre farklı içerikler gösterilebilir.*

# *NgClass Nedir?*

*NgClass, Angular'da kullanılan bir Directive'dir ve bir HTML öğesinin sınıflarını dinamik olarak yönetmek için kullanılır. Bu Directive, bir bileşen sınıfındaki bir değişkene veya bir işlevin sonucuna göre, HTML öğesinin sınıflarını ekleyebilir, çıkarabilir veya değiştirebilir.*

*NgClass, bir HTML öğesine uygulanabilir ve genellikle [ngClass] olarak yazılır. Bu Directive, bir nesne veya dizi olarak alınan sınıfları ve bir sınıfın eklenip eklenmeyeceğini belirleyen bir koşulu kabul eder. Koşul true ise, sınıf öğeye eklenir; koşul false ise, sınıf öğeden çıkarılır.*

*NgClass ayrıca nesneler ve diziler kullanarak birden fazla sınıfın eklenmesine izin verir. Nesne kullanarak sınıfların eklenmesi veya çıkarılması daha esnek ve okunaklı bir yöntemdir. Nesneler, sınıfları eklemek veya çıkarmak için anahtar-değer çiftleri olarak kullanılabilir.*

*NgClass, HTML öğelerine sınıfların dinamik olarak eklenebilmesini sağlar ve özellikle CSS işlemlerini kolaylaştıran bir Directive'dir. Örneğin, bir bileşenin durumuna göre, bir HTML öğesine belirli bir sınıfın eklenmesi veya çıkarılması gerekiyorsa NgClass kullanılabilir.*

# *NgStyle Nedir?*

*NgStyle, Angular'da kullanılan bir Directive'dir ve bir HTML öğesinin stil özelliklerini dinamik olarak yönetmek için kullanılır. Bu Directive, bir bileşenin stil değişkenine veya bir işlevin sonucuna göre, HTML öğesinin stil özelliklerini ekleyebilir, çıkarabilir veya değiştirebilir.*

*NgStyle, bir HTML öğesine uygulanabilir ve genellikle [ngStyle] olarak yazılır. Bu Directive, bir nesne veya dizi olarak alınan stil özellikleri ve bir koşulu kabul eder. Koşul true ise, stil özelliği öğeye eklenir; koşul false ise, stil özelliği öğeden çıkarılır.*

*NgStyle ayrıca nesneler ve diziler kullanarak birden fazla stil özelliğinin eklenmesine izin verir. Nesne kullanarak stil özelliklerinin eklenmesi veya çıkarılması daha esnek ve okunaklı bir yöntemdir. Nesneler, stil özelliklerini eklemek veya çıkarmak için anahtar-değer çiftleri olarak kullanılabilir.*

*NgStyle, HTML öğelerinin stil özelliklerinin dinamik olarak değiştirilmesini sağlar ve özellikle CSS işlemlerini kolaylaştıran bir Directive'dir. Örneğin, bir bileşenin durumuna göre, bir HTML öğesinin belirli bir stil özelliğinin değiştirilmesi gerekiyorsa NgStyle kullanılabilir.*

# *NgModel Nedir?*

*NgModel, Angular'da kullanılan bir Directive'dir ve HTML formlarındaki veri bağlantısını yönetmek için kullanılır. Bu Directive, form elemanlarının değerlerini bileşen sınıfındaki bir değişkene veya bir işlevin sonucuna bağlar ve veri değiştiğinde bileşen sınıfındaki değişkeni günceller.*

*NgModel, iki yönlü veri bağlama için kullanılır, yani bileşen sınıfındaki bir değişkenin değeri, HTML form elemanının değerine eşitlenir ve form elemanının değeri, bileşen sınıfındaki değişkenin değerine eşitlenir. Bu, kullanıcının bir form elemanında değişiklik yaptığında, bileşen sınıfındaki değişken otomatik olarak güncellenir ve aynı şekilde bileşen sınıfındaki değişken değiştirildiğinde, form elemanı otomatik olarak güncellenir.*

*NgModel, bir HTML form elemanına uygulanabilir ve genellikle [(ngModel)] olarak yazılır. Bu Directive, form elemanının değerini ve bir koşulu kabul eder. Koşul true ise, form elemanı etkinleştirilir; koşul false ise, form elemanı devre dışı bırakılır.*

*NgModel, HTML formlarındaki veri bağlantısını kolaylaştıran bir Directive'dir ve özellikle iki yönlü veri bağlama işlemlerini basitleştirir. Örneğin, bir kullanıcının bir form elemanındaki veriyi değiştirdiğinde, bu değişiklik bileşen sınıfındaki değişkeni otomatik olarak günceller ve bu veri işleme için kullanılabilir.*

# *Custom Directive Nasıl Yazılır?*

*Angular'da bir custom directive yazmak oldukça kolaydır. Aşağıdaki adımlarla bir custom directive yazabilirsiniz:*

1. *Yeni bir directive oluşturmak için öncelikle @Directive dekoratörünü kullanarak bir sınıf tanımlamanız gerekir. Bu dekoratör, directive'in özelliklerini belirtmek için kullanılır. Örneğin:*

```jsx
import { Directive, ElementRef, Input } from '@angular/core';

@Directive({
  selector: '[myCustomDirective]'
})
export class MyCustomDirective {
  constructor(private el: ElementRef) {
    el.nativeElement.style.backgroundColor = 'yellow';
  }
}
```

*Yukarıdaki örnekte, **`@Directive`** dekoratörü, **`MyCustomDirective`** adlı bir sınıfın tanımlandığını belirtir. **`selector`** özelliği, direktifin kullanılacağı HTML elementinin adını belirtir. Bu örnekte, **`myCustomDirective`** seçicisi, HTML'deki öğelerin bu directive'i kullanmasını sağlayacak.*

1. *Directive'i kullanacağınız bileşene, directive'i kullanacağına dair bilgiyi eklemek için **`@NgModule`** dekoratörünü kullanın. Directive, **`declarations`** listesine eklenerek bir bileşenle ilişkilendirilir. Örneğin:*

```jsx
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { MyCustomDirective } from './my-custom.directive';
import { AppComponent } from './app.component';

@NgModule({
  imports: [BrowserModule],
  declarations: [AppComponent, MyCustomDirective],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

*Yukarıdaki örnekte, **`MyCustomDirective`** sınıfı **`declarations`** listesine eklenir. Bu sayede, directive'i **`AppComponent`** bileşeni içinde kullanabiliriz.*

1. *Directive'in davranışını yazın. Bu, **`@Directive`** dekoratörü içinde tanımlanır. Yukarıdaki örnekte, **`constructor`** içindeki kod, HTML öğesinin arka plan rengini sarıya ayarlar.*
2. *Directive'i kullanın. **`selector`** özelliği ile tanımlandığı gibi, directive'i HTML'deki bir öğeye uygulayabilirsiniz. Örneğin:*

```jsx
<p myCustomDirective>
  Bu bir örnek cümledir.
</p>
```

*Yukarıdaki örnekte, **`myCustomDirective`** direktifi, **`<p>`** öğesine uygulanır. Bu, **`MyCustomDirective`** sınıfındaki özellikleri çalıştırarak öğenin arka plan rengini sarıya dönüştürür.*

*Bu şekilde bir custom directive oluşturarak, özel bir işlevsellik ekleyebilirsiniz. Directive, HTML elementlerine bir davranış ekleyerek, daha önce yapmadığı işleri yapabilir.*

# *Pipe Nedir?*

*Angular'da bir pipe, verileri değiştirmek veya düzenlemek için kullanılan bir araçtır. Bir veri dönüştürücüsü olarak da adlandırılan pipe, bir değeri alır ve işlemler yaparak başka bir değer döndürür. Pipe'lar, birçok veri türüne ve farklı veri formatlarına uygulanabilir.*

*Angular, bazı yerleşik pipe'lar sağlar. Bunlar, sıklıkla kullanılan veri dönüştürme işlemleri için hazır fonksiyonlar sağlar. Örneğin, **`uppercase`** ve **`lowercase`** pipe'ları, bir metin değerini büyük harfe veya küçük harfe dönüştürmek için kullanılır.*

*Ayrıca, Angular, özel pipe'lar oluşturmanıza da izin verir. Örneğin, bir tarih değerini belirli bir biçimde göstermek veya bir sayıyı belirli bir formatta biçimlendirmek için özel bir pipe yazabilirsiniz.*

*Pipe'lar, Angular bileşenlerinde veya direktiflerinde kullanılabilir. Pipe'ları kullanmak için, **`|`** (boru) işareti kullanarak belirtilen bir değişkenin değerine uygulanır. Örneğin:*

```jsx
{{ name | uppercase }}
```

*Yukarıdaki örnekte, **`name`** değişkeninin değeri, **`uppercase`** pipe'ı kullanılarak büyük harflere dönüştürülür.*

*Angular'da kullanılabilen bazı yerleşik pipe'lar şunlardır:*

- **`*uppercase`**: Metin değerini büyük harfe dönüştürür.*
- **`*lowercase`**: Metin değerini küçük harfe dönüştürür.*
- **`*date`**: Tarih değerini belirli bir formatta gösterir.*
- **`*currency`**: Sayı değerini belirli bir para birimi formatında gösterir.*
- **`*json`**: Nesne değerini JSON formatında gösterir.*

*Pipe'lar, verileri dönüştürmek veya düzenlemek için güçlü bir araçtır. Kendi özel pipe'larınızı yazarak, verilerinizi daha okunaklı ve kullanılabilir hale getirebilirsiniz.*

# *Pipe Türleri Nelerdir?*

*Angular'da, farklı veri türleri ve kullanım senaryoları için birçok farklı pipe türü vardır. Bunlar arasında:*

1. *Pure Pipe: Bu tür bir pipe, girdi değerleri değiştiğinde çalışan bir fonksiyon içerir. Yani, girdi değeri değiştiğinde, pipe'ın yalnızca etkilenen bileşenleri yeniden işlemesi gerekir. Örneğin, bir sayı veya tarih değerini biçimlendirmek için kullanılan **`DatePipe`** veya **`CurrencyPipe`** gibi yerleşik pipe'lar, saf bir pipe örneğidir.*
2. *Impure Pipe: Bu tür bir pipe, bileşenin tamamı yeniden işleme gerektiren, kapsamlı bir hesaplama işlemi içerir. Impure pipe'lar, bileşenin yeniden işlenmesi gerektiğinde her zaman çalışır ve bu nedenle performans açısından daha düşük bir seçenektir. Ancak, bazı durumlarda, girdi değerlerinde sürekli değişiklikler olduğunda veya kompleks bir hesaplama işlemi yapılması gerektiğinde kullanışlı olabilir.*
3. *Async Pipe: Bu tür bir pipe, bir Observable veya Promise gibi asenkron bir değeri göstermek için kullanılır. Async pipe, abone olduğu veriyi otomatik olarak yönetir ve güncelleme işlemlerini gerçekleştirir.*
4. *Custom Pipe: Bu tür bir pipe, özelleştirilmiş bir işlevsellik sağlamak için kullanıcı tarafından oluşturulur. Kendi özel pipe'larınızı yazarak, verileri belirli bir biçimde göstermek veya düzenlemek için ihtiyacınız olan özel işlemleri gerçekleştirebilirsiniz.*

*Bu pipe türleri, Angular'da veri dönüştürme işlemlerini gerçekleştirmek için kullanılabilir ve her biri belirli bir senaryo veya veri türü için daha uygun olabilir.*

# *Custom Nasıl Pipe Yazılır?*

*Angular'da custom pipe yazmak oldukça kolaydır. Aşağıdaki adımları izleyerek kendi custom pipe'ınızı yazabilirsiniz:*

1. *Yeni bir pipe oluşturun: Yeni bir pipe oluşturmak için Angular CLI aracını kullanabilirsiniz. Komut istemcisinde **`ng generate pipe`** komutunu çalıştırarak yeni bir pipe oluşturabilirsiniz. Örneğin, **`ng generate pipe myCustomPipe`** komutu ile **`myCustomPipe`** adında yeni bir pipe oluşturabilirsiniz.*
2. *Pipe sınıfını oluşturun: Yeni bir pipe oluşturduktan sonra, pipe sınıfınızı **`@Pipe`** dekoratörü ile işaretleyin. Bu dekoratör, pipe'ın adını belirlemenizi ve hangi modüle dahil edileceğini tanımlamanızı sağlar. Ayrıca **`PipeTransform`** arayüzünü de uygulamanız gerekir.*

```jsx
*import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'myCustomPipe'
})
export class MyCustomPipe implements PipeTransform {
  transform(value: any, arg1: any, arg2: any): any {
    // Pipe işlemlerini burada gerçekleştirin
  }
}*
```

1. *Pipe işlevselliğini yazın: **`PipeTransform`** arayüzü, transform() adında tek bir yöntem içerir. Bu yöntem, pipe'ın verileri nasıl dönüştüreceğini belirtir. Yani, burada custom pipe'ınızın gerçek işlemlerini gerçekleştirirsiniz.*

```jsx
*transform(value: any, arg1: any, arg2: any): any {
  // value, pipe'a gelen veridir
  // arg1, pipe'a verilen ilk parametredir
  // arg2, pipe'a verilen ikinci parametredir

  // pipe işlemleri burada gerçekleştirilir
  // işlemler sonucu oluşan veri döndürülür
}*
```

1.  *Pipe'i kullanın: Pipe'ınızı kullanmak için, bileşen dosyanızda veya HTML dosyanızda pipe adını kullanarak boru (|) sembolü ile birlikte belirtmeniz yeterlidir. Örneğin:*

```jsx
*<!-- Pipe, {{}} ifadesi içinde kullanılabilir -->
{{ myData | myCustomPipe: arg1: arg2 }}

<!-- Pipe, direktif parametrelerinde kullanılabilir -->
<div [ngClass]="{ 'my-class': myData | myCustomPipe: arg1: arg2 }"></div>*
```

*Yukarıdaki adımları izleyerek, Angular'da kendi özelleştirilmiş pipe'ınızı yazabilirsiniz. Bu, verileri özelleştirilmiş bir şekilde işlemek için kullanışlı bir araçtır ve özellikle birden çok bileşende aynı işlemleri gerçekleştirmek istediğinizde faydalıdır.*

# *Template Driven Nedir?*

*Template Driven, Angular'da bir form yaklaşımıdır. Bu yaklaşımda, formun mantıksal işlevleri component dosyasında değil, HTML template'ında tanımlanır. Bu nedenle, form oluşturma süreci daha hızlı ve basittir.*

*Template Driven yaklaşımı, form elemanlarına doğrudan ngModel direktifi atanarak veri bağlama (data binding) yapılmasına izin verir. Form elemanlarının geçerliliği (validity) otomatik olarak kontrol edilir ve gösterilir. Bu yaklaşımın avantajlarından biri, HTML tarafında yapılandırmanın basit olmasıdır.*

*Ancak, büyük projelerde Template Driven yaklaşımı yerine Reactive Forms yaklaşımının kullanılması tavsiye edilir. Reactive Forms, form mantığının tamamen TypeScript tarafında kontrol edildiği ve form elemanlarının daha kolay test edildiği bir yaklaşımdır.*

# *Reactive Form Nedir?*

*Reactive Forms, Angular'da bir form yaklaşımıdır. Bu yaklaşımda, form elemanları ve işlevleri component dosyasında TypeScript koduyla kontrol edilir. Reactive Forms, Template Driven yaklaşımına göre daha özelleştirilebilir ve ölçeklenebilirdir.*

*Reactive Forms, FormBuilder sınıfı yardımıyla formun kontrolünün tamamen component dosyasında yapılmasına izin verir. Form elemanları ve özellikleri, FormGroup ve FormControl nesneleri aracılığıyla yönetilir. Form elemanlarına doğrudan ngModel direktifi atanması yerine, FormControl nesneleri ile veri bağlama (data binding) yapılır.*

*Reactive Forms, form elemanlarının daha iyi test edilmesine izin verir ve form elemanlarına yapılan işlemler TypeScript koduyla daha kolay takip edilebilir. Reactive Forms'un dezavantajlarından biri, HTML template tarafında yapılandırmanın daha karmaşık olmasıdır. Ancak, büyük projelerde Reactive Forms'un Template Driven yaklaşıma göre daha avantajlı olduğu düşünülmektedir.*

# *Service Nedir?*

*Service, Angular uygulamalarında, componentler arasında paylaşılan verilerin, fonksiyonların ve işlemlerin tutulduğu ve sağlandığı bir sınıftır.*

*Service sınıfları, bir iş mantığını veya API çağrılarını gerçekleştirmek, verileri depolamak ve paylaşmak, tarih formatlama gibi işlemleri yapmak için kullanılabilirler. Service sınıfları, Angular'ın dependency injection (bağımlılık enjeksiyonu) mekanizması ile çalışır ve bu sayede componentler arasında veri paylaşımı sağlanır.*

*Service'ler, componentlerin kendi özelliklerinden bağımsızdır ve birden fazla component tarafından kullanılabilirler. Bu nedenle, bir veri kaynağına erişmeniz gerektiğinde, tüm componentlerin aynı veri kaynağına erişmesini sağlayacak bir service oluşturabilirsiniz.*

*Angular, genellikle RESTful servisler üzerinde çalıştığından, HTTPClient gibi Angular servislerini kullanarak bir API ile veri etkileşimlerini gerçekleştirmek yaygındır.*

# *Module Provider Nedir?*

*Module Provider, Angular uygulamalarında, dependency injection (bağımlılık enjeksiyonu) mekanizmasının kullanılması için gereken servis, değer veya farklı bir bağımlılık türünün sağlandığı bir yapıdır.*

*Module Provider, bir NgModule içinde yer alır ve özellikle module'ün dışındaki bir dependency'in NgModule'e sağlanması gerektiğinde kullanılır. NgModule içinde bir provider tanımlandığında, dependency injection ile tüm uygulama genelinde bu servis kullanılabilir hale gelir.*

*Module Provider, bir servisin nasıl sağlandığını belirlemek için kullanılan Injectable decorator'ı kullanır. Bu sayede Angular'ın dependency injection mekanizması, servis sağlayıcılarının ne zaman ve nasıl sağlanacağını bilir.*

*Örneğin, bir RESTful API'ya HTTP istekleri gönderen bir servisi kullanmak istiyorsak, bu servisi sağlayacak bir HTTPClientModule sağlayıcısı ekleyerek, uygulamanın tümünde bu servisi kullanabilir hale getirebiliriz.*

# *Module Nedir?*

*Module, Angular uygulamalarında, componentler, directive'ler, pipe'lar, servisler ve diğer NgModule'ler gibi birçok yapıyı bir araya getiren bir yapıdır. NgModule, Angular'ın modüler mimarisinin temelini oluşturur.*

*Module'ler, uygulamanın modüler bir şekilde tasarlanmasına yardımcı olurlar ve uygulama componentleri arasında veri paylaşımını sağlarlar. Her Angular uygulaması, en az bir AppModule (Root Module) içermelidir. Root module, uygulama genelinde kullanılacak componentler, directive'ler, pipe'lar ve servisler gibi yapıları tanımlayan NgModule'dir.*

*Module'ler, birbirleri ile ilişkili olan componentler, directive'ler, pipe'lar ve servisleri gruplamak için kullanılırlar. Bu sayede, uygulamanın belli bir bölümü için gereken yapılar tek bir NgModule içinde tanımlanabilir. Böylece, uygulamanın farklı bölümlerinde aynı yapıları farklı NgModule'lerde tekrar tekrar tanımlamak yerine, bu yapıları bir kez tanımlayarak tüm uygulama boyunca kullanılabilir hale getirebiliriz.*

*NgModule'ler, Angular uygulamalarında dependency injection (bağımlılık enjeksiyonu) mekanizmasını da sağlarlar. Yani, herhangi bir yapıyı (component, directive, pipe, servis vb.) herhangi bir yerde kullanmak istediğimizde, NgModule içindeki provider'ları kullanarak bu yapıları dependency injection ile sağlayabiliriz.*

# *Module Nasıl Oluşturulur?*

*Angular uygulamalarında, bir module oluşturmak için öncelikle **`@NgModule()`** dekoratörünü kullanmamız gerekiyor. Bu dekoratör, module için gerekli olan metadata'ları sağlar.*

*Module oluşturmak için öncelikle, CLI(Command Line Interface) aracını kullanarak aşağıdaki komutu çalıştırabilirsiniz:*

```jsx
ng generate module <module-name>
```

*Bu komutla birlikte, Angular CLI size yeni bir module dosyası ve bu dosyayı içe aktarabileceğiniz bir dosya da oluşturacaktır.*

*Module dosyası içinde ise, **`@NgModule()`** dekoratörü ile tanımlanan metadata'ları sağlamalısınız. Bu metadata'lar arasında, module içinde kullanılacak componentler, directive'ler, pipe'lar, servisler ve diğer NgModule'ler gibi yapılar yer alır.*

*Aşağıda, basit bir örnek olarak yeni bir module oluşturmayı gösterebilirim:*

```jsx
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MyComponent } from './my.component';

@NgModule({
  declarations: [
    MyComponent
  ],
  imports: [
    CommonModule
  ],
  exports: [
    MyComponent
  ]
})
export class MyModule { }
```

*Yukarıdaki örnekte, **`MyModule`** adında bir module oluşturduk. Bu module, **`MyComponent`** adında bir component içeriyor. **`CommonModule`** ise Angular tarafından sağlanan bir module'dur ve bazı temel direktivleri içerir. **`exports`** array'i ile de module içinde yer alan componentlerin veya diğer yapıların dışarıya aktarılmasını sağlayabiliriz. Bu sayede, bu module'ü kullanan diğer componentler veya module'ler, bu yapıları kullanabilirler.*

# *Routing Nedir?*

*Angular uygulamalarında, routing (yönlendirme) yapısı, kullanıcının URL adreslerine göre farklı componentlerin görüntülenmesini sağlar. Bu sayede, farklı sayfaların veya farklı bileşenlerin kullanıcıya gösterilmesi mümkün hale gelir.*

*Angular, routing yapısı için **`@angular/router`** modülünü sağlar. Bu modül ile birlikte, **`Routes`** ve **`RouterModule`** sınıflarını kullanarak routing işlemleri gerçekleştirilir.*

**`*Routes`** sınıfı, uygulama içinde yönlendirme yapısı için kullanılacak olan URL adreslerini ve bu adreslere karşılık gelen componentleri tanımlamak için kullanılır. **`RouterModule`** sınıfı ise, uygulama modülü içinde yönlendirme yapısı için gerekli olan özellikleri sağlar.*

*Routing yapısı, örneğin bir web sayfasındaki menü seçenekleri ile sağlanabilir. Menüdeki her bir seçenek, farklı bir URL adresi ile ilişkilendirilir ve bu adreslere göre farklı componentler görüntülenir.*

*Aşağıda, örnek bir routing yapısı tanımlanmıştır:*

```jsx
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

import { HomeComponent } from './home.component';
import { AboutComponent } from './about.component';
import { ContactComponent } from './contact.component';

const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'about', component: AboutComponent },
  { path: 'contact', component: ContactComponent },
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

*Yukarıdaki örnekte, **`Routes`** sınıfı kullanılarak üç farklı URL adresi ve bu adreslere karşılık gelen componentler tanımlanmıştır: **`/`** adresi için **`HomeComponent`**, **`/about`** adresi için **`AboutComponent`**, **`/contact`** adresi için ise **`ContactComponent`**.*

*Daha sonra, **`AppRoutingModule`** adında bir modül oluşturarak, **`RouterModule.forRoot()`** metodunu kullanarak tanımlanan routes değişkenini içeri aktarabiliriz. Bu sayede, uygulama içinde yönlendirme işlemleri için gerekli olan ayarlar sağlanmış olur.*

*Routing yapısı, ayrıca URL adreslerinde yer alan parametreler ve query string'ler gibi dinamik verilerin de kullanılabilmesini sağlar. Bu sayede, farklı verileri aynı component içinde kullanarak daha dinamik uygulamalar oluşturmak mümkün hale gelir.*

# *RxJS Nedir?*

*RxJS, Reactive Extensions for JavaScript' in kısaltmasıdır. Bu, reaktif programlama kavramlarına dayalı olarak geliştirilmiş bir JavaScript kütüphanesidir. Reactive programming, verilerin asenkron olarak işlenmesine odaklanır ve bu veriler üzerinde işlem yapmak için birçok farklı operatör sağlar.*

*RxJS, bir dizi observable nesnesi üzerinde çalışarak, yani nesneler arasındaki bir etkileşim olduğunda, bu etkileşimleri ele almak için tasarlanmıştır. Bu nesneler, gelecekte oluşacak olan etkileşimleri temsil ederler ve herhangi bir zamanda işlem yapmak üzere abone olunabilirler.*

*RxJS, web uygulamalarında asenkron veri işleme işlemlerini yönetmek için çok yararlıdır. Bu kütüphane sayesinde, HTTP isteklerinin sonuçları, kullanıcı etkileşimleri veya zamanla değişen veriler gibi asenkron verileri işleyebilirsiniz. Ayrıca, RxJS, Angular gibi modern web çerçeveleri ve kütüphaneleri ile birlikte kullanıldığında, veri akışını daha kolay yönetmenize ve uygulamanızın performansını artırmanıza yardımcı olur.*

# *Observable Nesne Nedir?*

*Observable, asenkron verilerin yayınlanmasını temsil eden bir nesnedir. Bu nesne, olası bir etkileşim olan bir veri akışını temsil eder ve bu veri akışı, bir veya daha fazla değer yayınlayabilir.*

*Observable, bir dizi operatör kullanarak bu veri akışlarını manipüle edebilir. Örneğin, bir Observable nesnesi, map() operatörü kullanılarak bir veri akışındaki her bir değeri dönüştürebilir veya filter() operatörü kullanılarak belirli bir kritere uyan değerler filtrelenerek yeni bir veri akışı oluşturulabilir.*

*Observable nesnesi, bir veya daha fazla abone işlevi tarafından dinlenebilir. Bu abone işlevleri, Observable nesnesindeki her bir değeri veya bir hata mesajını veya Observable nesnesinin tamamlandığını alma yeteneğine sahiptir. Abone işlevi, Observable nesnesindeki değişiklikleri takip ederek, veri akışını dinamik olarak yönetmenize olanak tanır.*

*Observable, RxJS kütüphanesi gibi reaktif programlama kütüphanelerinde sıklıkla kullanılır ve modern web uygulamalarında, özellikle Angular gibi web çerçeveleri ve kütüphanelerinde kullanılır.*

# *Creation Operators Nedir Türleri Nelerdir?*

*RxJS, Observable nesnelerinin oluşturulması için bir dizi yararlı işlev içerir. Bu işlevlere Creation Operators denir ve Observable nesnesini oluşturmanın farklı yollarını sunar. Creation Operators, Observable nesnesinin verileri nasıl üreteceğini belirleyen işlevlerdir. Bazı Creation Operators türleri şunlardır:*

1. ***of():** Belirtilen bir dizi veya değer kümesini içeren bir Observable nesnesi oluşturur.*
2. ***from():** Bir dizi, bir promise, bir iterable, bir Observable nesnesi veya başka bir kaynaktan bir Observable nesnesi oluşturur.*
3. ***interval():** Belirli bir zaman aralığı içinde tekrar eden bir Observable nesnesi oluşturur.*
4. ***timer():** Belirli bir gecikme süresi sonrasında bir değer veya değer kümesi yayınlayan bir Observable nesnesi oluşturur.*
5. ***defer():** Abone işlevi her çağrıldığında Observable nesnesinin oluşturulduğu bir Observable nesnesi oluşturur.*
6. ***range():** Belirtilen aralıktaki tamsayı değerleri içeren bir Observable nesnesi oluşturur.*

*Bu Creation Operators türleri, Observable nesnelerinin nasıl oluşturulacağına dair sadece birkaç örnektir. RxJS, daha birçok yararlı Creation Operators işlevi sunar.*

# *Filtering Operators Nedir Türleri Nelerdir?*

*RxJS, Observable nesnesindeki verileri filtrelemek için birçok yararlı işlev içerir. Bu işlevlere Filtering Operators denir ve Observable nesnesinin içindeki verileri değiştirmeden, yalnızca belirli koşullara göre filtreleyerek, değiştirerek veya yeniden düzenleyerek çalışır. Bazı Filtering Operators türleri şunlardır:*

1. ***filter():** Belirli bir koşulu karşılayan verileri içeren yeni bir Observable nesnesi oluşturur.*
2. ***take():** Belirli bir sayıda veri yayınlayan bir Observable nesnesi oluşturur.*
3. ***skip():** Belirli bir sayıda veri atlama işlemi yapar ve geri kalan verileri içeren yeni bir Observable nesnesi oluşturur.*
4. ***distinct():** Yayınlanan benzersiz değerleri içeren yeni bir Observable nesnesi oluşturur.*
5. ***debounceTime():** Belirli bir süre boyunca verileri toplayarak, belirli bir zaman aralığından sonra son veriyi içeren yeni bir Observable nesnesi oluşturur.*
6. ***throttleTime():** Belirli bir zaman aralığı boyunca belirli bir sayıda veri yayınlayan bir Observable nesnesi oluşturur.*

*Bu Filtering Operators türleri, Observable nesnesindeki verileri nasıl filtreleyeceğinize dair yalnızca birkaç örnektir. RxJS, daha birçok yararlı Filtering Operators işlevi sunar.*

# *Transformation Operators Nedir Türleri Nelerdir?*

*RxJS, Observable nesnesindeki verileri dönüştürmek için birçok yararlı işlev içerir. Bu işlevlere Transformation Operators denir ve Observable nesnesinin içindeki verileri değiştirerek veya yeniden düzenleyerek çalışırlar. Bazı Transformation Operators türleri şunlardır:*

1. ***map():** Observable nesnesindeki her veriyi belirli bir işleme tabi tutarak, yeni bir Observable nesnesi oluşturur.*
2. ***pluck():** Belirli bir nesne özelliğine erişmek için kullanılır.*
3. ***mergeMap():** Observable nesnesindeki her veri için yeni bir Observable nesnesi oluşturur ve bu nesneleri birleştirerek tek bir Observable nesnesi oluşturur.*
4. ***switchMap():** Observable nesnesindeki her veri için yeni bir Observable nesnesi oluşturur ve önceki Observable nesnesini iptal ederek yalnızca en son oluşan nesneyi yayınlar.*
5. ***reduce():** Observable nesnesindeki tüm verileri tek bir değerde birleştirerek yeni bir Observable nesnesi oluşturur.*
6. ***scan():** Observable nesnesindeki tüm verileri tek bir değerde birleştirerek, her veri akışı için yeni bir değer yayınlayan yeni bir Observable nesnesi oluşturur.*

*Bu Transformation Operators türleri, Observable nesnesindeki verileri nasıl dönüştüreceğinize dair yalnızca birkaç örnektir. RxJS, daha birçok yararlı Transformation Operators işlevi sunar.*

# *Utility Operators Nedir Türleri Nelerdir?*

*RxJS, Observable nesnesindeki verileri manipüle etmek için kullanabileceğiniz birçok Utility Operators işlevi içerir. Bu işlevler, Observable nesnesinin içindeki verilerin durumunu kontrol etmenize, Observable nesnesinin oluşturma veya sonlandırma davranışını değiştirmenize ve verileri işlemek için ek işlevler eklemenize olanak tanır. Bazı Utility Operators türleri şunlardır:*

1. ***tap():** Observable nesnesindeki her veri akışına ek bir işlem ekler, ancak verileri değiştirmez.*
2. ***delay():** Observable nesnesinin verilerinin yayınlanmasını belirli bir süre geciktirir.*
3. ***throttleTime():** Belirli bir süre boyunca, Observable nesnesindeki verilerin sadece belirli bir sıklıkta yayınlanmasını sağlar.*
4. ***catchError():** Observable nesnesindeki hataları ele alır ve bir hata olduğunda başka bir Observable nesnesi yayınlar.*
5. ***retry():** Observable nesnesindeki hataları ele alır ve belirli bir sayıda yeniden deneme yapar.*
6. ***finalize():** Observable nesnesinin sonlandırılmasından önce herhangi bir işlem yapar.*

*Bu Utility Operators türleri, Observable nesnesinin içindeki verileri nasıl manipüle edebileceğinize dair yalnızca birkaç örnektir. RxJS, daha birçok yararlı Utility Operators işlevi sunar.*

# *HttpClient Service Nedir?*

*Angular, HTTP isteklerini yönetmek için HttpClient servisini sağlar. HttpClient servisi, Angular uygulamalarınızda API’lere HTTP isteklerini göndermek ve cevapları almak için kullanılır.*

*HttpClient servisi, Angular uygulamalarında önceden yüklenmiş bir modül olan HttpClientModule modülü aracılığıyla sağlanır. Bu modülü projenize ekledikten sonra, HttpClient servisini kullanmaya başlayabilirsiniz.*

*HttpClient servisi, GET, POST, PUT, DELETE vb. gibi yaygın HTTP isteklerini yönetmek için bir dizi yöntem sunar. Ayrıca, istekleri yapılandırmak için birçok seçenek de sunar. Örneğin, istek başlıkları ekleyebilir, parametreler ayarlayabilir veya cevapları belirli bir veri tipine dönüştürebilirsiniz.*

*HttpClient servisini kullanarak API’lere HTTP istekleri yapmak, Angular uygulamalarının birçok farklı senaryosunda gereklidir. Örneğin, kullanıcının bir formu doldurmasından sonra verileri bir sunucuya kaydetmek veya verileri bir API’den çekmek ve Angular uygulamanızda göstermek için kullanabilirsiniz.*

# *Route Resolver Nedir?*

*Route Resolver, Angular’da yönlendirmeler (routing) sırasında kullanılan bir tekniktir. Angular, bir URL isteği karşılandığında, genellikle ilgili bileşenin yüklenmesi için bir HTTP isteği gönderir. Ancak, bazı durumlarda, bileşenin yüklenmesi için gerekli olan veriler önceden yüklenmelidir. İşte bu noktada Route Resolver devreye girer.*

*Route Resolver, belirli bir URL isteği için gerekli olan verileri önceden yükler ve bunları bir bileşen yüklenmeden önce hazır hale getirir. Bu, kullanıcılara daha hızlı ve pürüzsüz bir deneyim sunar, çünkü bileşen yüklendiğinde gerekli olan veriler zaten mevcuttur.*

*Route Resolver, genellikle Observable öğeleri döndüren bir servis tarafından sağlanır. Bu servis, verileri bir API’den çekebilir veya yerel depolama gibi başka kaynaklardan getirebilir. Resolver, Route ile birlikte tanımlanır ve URL isteği karşılandığında çalışır. Resolver, veriler hazır olduğunda bileşene geçirilir.*

*Route Resolver, Angular uygulamalarının performansını artırmak ve kullanıcıların deneyimini geliştirmek için önemli bir tekniktir. Ancak, doğru şekilde kullanılması önemlidir, çünkü yanlış kullanımı uygulamanın yavaşlamasına ve performans sorunlarına neden olabilir.*